// Generated by dts-bundle-generator v5.9.0

export declare type JsonValue = JsonPrimitiveValue | JsonArray<any> | JsonObject<any> | undefined;
export declare type JsonPrimitiveValue = string | number | boolean | null;
export declare type JsonArray<T extends JsonValue> = T[];
export declare type JsonObject<T extends JsonValue = JsonValue> = {
	[key: string]: T;
};
export interface JsonAdapter<T, U extends JsonValue = JsonValue> {
	adaptToJson(value: T): U;
	recoverFromJson(value: U): T;
}
export declare class JsonConverter<T> {
	#private;
	constructor(adapter: JsonAdapter<T, any>);
	stringify(value: T, space?: string | number): string;
	parse(text: string): T;
}
export declare type StringKeyOf<T> = string & keyof T;
export declare type NullishValue = null | undefined;
export declare type Nullable<T> = T | NullishValue;
export declare type NullishAwareJsonAdapter<T, U extends JsonValue = JsonValue> = JsonAdapter<Nullable<T>, Nullable<U>>;
export declare type RecursiveNullable<T> = Nullable<{
	[P in keyof T]: Nullable<T[P] extends (infer U)[] ? RecursiveNullable<U>[] : T[P] extends object ? RecursiveNullable<T[P]> : T[P]>;
}>;
declare function getIdentityAdapter<T extends JsonValue = JsonValue>(): NullishAwareJsonAdapter<T, T>;
declare function getISODateAdapter(): NullishAwareJsonAdapter<Date, string>;
declare function getDateTimestampAdapter(): NullishAwareJsonAdapter<Date, number>;
declare function getArrayJsonAdapter<T, U extends JsonValue = JsonValue>(elementAdapter: JsonAdapter<T, U>): NullishAwareJsonAdapter<T[], JsonArray<U>>;
declare function getSetAdapter<T extends JsonValue = JsonValue>(): NullishAwareJsonAdapter<Set<T>, JsonArray<T>>;
declare function getSetAdapter<T, U extends JsonValue = JsonValue>(elementAdapter: JsonAdapter<T, U>): NullishAwareJsonAdapter<Set<T>, JsonArray<U>>;
declare function getRecordAdapter<T, U extends JsonValue = JsonValue>(valueAdapter: JsonAdapter<T, U>): NullishAwareJsonAdapter<Record<string, T>, JsonObject<U>>;
export declare type MapEntry<K, V> = [
	K,
	V
];
export interface MapAdapterConfig<K, V, JK extends JsonValue = JsonValue, JV extends JsonValue = JsonValue> {
	keyAdapter: JsonAdapter<K, JK>;
	valueAdapter: JsonAdapter<V, JV>;
}
declare function getMapAsEntriesAdapter<K, V, JK extends JsonValue = JsonValue, JV extends JsonValue = JsonValue>(config?: Partial<MapAdapterConfig<K, V, JK, JV>>): NullishAwareJsonAdapter<Map<K, V>, JsonArray<MapEntry<JK, JV>>>;
declare function getMapAsRecordAdapter<K, V, JV extends JsonValue = JsonValue>(config?: Partial<MapAdapterConfig<K, V, string, JV>>): NullishAwareJsonAdapter<Map<K, V>, JsonObject<JV>>;
export declare type PropertyAdapters<T> = {
	[K in keyof T]?: JsonAdapter<RecursiveNullable<T[K]>, any>;
};
export interface ObjectAdapterConfig<T> {
	omitUnmappedProperties: boolean;
	omittedProperties: (keyof T)[];
}
declare function getObjectAdapter<T>(propertyAdapters: PropertyAdapters<T>, config?: Partial<ObjectAdapterConfig<T>>): NullishAwareJsonAdapter<T, JsonObject>;
declare function getByKeyAdapter<T, R extends Record<string, T>>(keyValuePairs: R, fallbackKey?: StringKeyOf<R>): NullishAwareJsonAdapter<T, StringKeyOf<R>>;
declare function getCustomAdapter<T, U extends JsonValue = JsonValue>(adapter: JsonAdapter<T, U>): JsonAdapter<T, U>;
declare function getNullishAwareCustomAdapter<T, U extends JsonValue = JsonValue>(adapter: JsonAdapter<T, U>): NullishAwareJsonAdapter<T, U>;
export declare const JsonAdapters: {
	identity: typeof getIdentityAdapter;
	isoDate: typeof getISODateAdapter;
	dateTimestamp: typeof getDateTimestampAdapter;
	array: typeof getArrayJsonAdapter;
	set: typeof getSetAdapter;
	record: typeof getRecordAdapter;
	mapAsEntries: typeof getMapAsEntriesAdapter;
	mapAsRecord: typeof getMapAsRecordAdapter;
	object: typeof getObjectAdapter;
	byKey: typeof getByKeyAdapter;
	custom: typeof getCustomAdapter;
	nullishAwareCustom: typeof getNullishAwareCustomAdapter;
};

export {};
